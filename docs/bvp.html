<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Numerical Analysis - 11&nbsp; Boundary Value Problems</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./pde.html" rel="next">
<link href="./ivp.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Numerical Analysis - 11&nbsp; Boundary Value Problems">
<meta property="og:description" content="">
<meta property="og:site_name" content="Numerical Analysis">
<meta name="twitter:title" content="Numerical Analysis - 11&nbsp; Boundary Value Problems">
<meta name="twitter:description" content="">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./bvp.html"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Boundary Value Problems</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Numerical Analysis</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://maths.york.ac.uk/moodle/course/view.php?id=2497" title="Moodle page" class="quarto-navigation-tool px-1" aria-label="Moodle page"><i class="bi bi-mortarboard-fill"></i></a>
    <a href="https://forms.gle/w17c19vWnM7wpLpz7" title="Submit a correction" class="quarto-navigation-tool px-1" aria-label="Submit a correction"><i class="bi bi-bug-fill"></i></a>
    <a href="https://github.com/gustavdelius/NumericalAnalysis/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./Numerical-Analysis.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Errors</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Solving nonlinear equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Solving systems of nonlinear equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter05.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Iterative techniques for solving systems of linear equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter06.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Approximation and interpolation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter07.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Numerical integration</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter08.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Numerical differentiation</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter09.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">A direct method for solving tridiagonal linear systems</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ivp.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Initial Value Problems</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./bvp.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Boundary Value Problems</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pde.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Partial Differential Equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./appendix.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Appendix</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-fundamentals" id="toc-sec-fundamentals" class="nav-link active" data-scroll-target="#sec-fundamentals"><span class="header-section-number">11.1</span> Fundamentals</a>
  <ul class="collapse">
  <li><a href="#a-criterion" id="toc-a-criterion" class="nav-link" data-scroll-target="#a-criterion"><span class="header-section-number">11.1.1</span> A criterion</a></li>
  <li><a href="#linear-odes" id="toc-linear-odes" class="nav-link" data-scroll-target="#linear-odes"><span class="header-section-number">11.1.2</span> Linear ODEs</a></li>
  <li><a href="#approximation-methods" id="toc-approximation-methods" class="nav-link" data-scroll-target="#approximation-methods"><span class="header-section-number">11.1.3</span> Approximation methods</a></li>
  </ul></li>
  <li><a href="#the-shooting-method" id="toc-the-shooting-method" class="nav-link" data-scroll-target="#the-shooting-method"><span class="header-section-number">11.2</span> The Shooting Method</a>
  <ul class="collapse">
  <li><a href="#the-idea" id="toc-the-idea" class="nav-link" data-scroll-target="#the-idea"><span class="header-section-number">11.2.1</span> The idea</a></li>
  <li><a href="#systematic-approach" id="toc-systematic-approach" class="nav-link" data-scroll-target="#systematic-approach"><span class="header-section-number">11.2.2</span> Systematic Approach</a></li>
  <li><a href="#linear-shooting" id="toc-linear-shooting" class="nav-link" data-scroll-target="#linear-shooting"><span class="header-section-number">11.2.3</span> Linear Shooting</a></li>
  <li><a href="#nonlinear-shooting" id="toc-nonlinear-shooting" class="nav-link" data-scroll-target="#nonlinear-shooting"><span class="header-section-number">11.2.4</span> Nonlinear Shooting</a></li>
  </ul></li>
  <li><a href="#sec-fdm" id="toc-sec-fdm" class="nav-link" data-scroll-target="#sec-fdm"><span class="header-section-number">11.3</span> The Finite Difference Method</a>
  <ul class="collapse">
  <li><a href="#the-idea-1" id="toc-the-idea-1" class="nav-link" data-scroll-target="#the-idea-1"><span class="header-section-number">11.3.1</span> The idea</a></li>
  <li><a href="#centred-difference-formulas" id="toc-centred-difference-formulas" class="nav-link" data-scroll-target="#centred-difference-formulas"><span class="header-section-number">11.3.2</span> Centred difference formulas</a></li>
  <li><a href="#recipe-for-the-finite-difference-method" id="toc-recipe-for-the-finite-difference-method" class="nav-link" data-scroll-target="#recipe-for-the-finite-difference-method"><span class="header-section-number">11.3.3</span> Recipe for the Finite Difference Method</a></li>
  <li><a href="#the-linear-finite-difference-method" id="toc-the-linear-finite-difference-method" class="nav-link" data-scroll-target="#the-linear-finite-difference-method"><span class="header-section-number">11.3.4</span> The Linear Finite Difference Method</a></li>
  <li><a href="#the-nonlinear-finite-difference-method" id="toc-the-nonlinear-finite-difference-method" class="nav-link" data-scroll-target="#the-nonlinear-finite-difference-method"><span class="header-section-number">11.3.5</span> The Nonlinear Finite Difference Method</a></li>
  </ul></li>
  <li><a href="#sec-rritz" id="toc-sec-rritz" class="nav-link" data-scroll-target="#sec-rritz"><span class="header-section-number">11.4</span> The Rayleigh-Ritz Method</a>
  <ul class="collapse">
  <li><a href="#motivation" id="toc-motivation" class="nav-link" data-scroll-target="#motivation"><span class="header-section-number">11.4.1</span> Motivation</a></li>
  <li><a href="#equivalence-of-bvps-with-minimization-problems" id="toc-equivalence-of-bvps-with-minimization-problems" class="nav-link" data-scroll-target="#equivalence-of-bvps-with-minimization-problems"><span class="header-section-number">11.4.2</span> Equivalence of BVPs with minimization problems</a></li>
  <li><a href="#approximating-the-integral" id="toc-approximating-the-integral" class="nav-link" data-scroll-target="#approximating-the-integral"><span class="header-section-number">11.4.3</span> Approximating the integral</a></li>
  <li><a href="#choosing-the-basis-functions" id="toc-choosing-the-basis-functions" class="nav-link" data-scroll-target="#choosing-the-basis-functions"><span class="header-section-number">11.4.4</span> Choosing the basis functions</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/gustavdelius/NumericalAnalysis/edit/master/bvp.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-bvp" class="quarto-section-identifier"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Boundary Value Problems</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="sec-fundamentals" class="level2" data-number="11.1">
<h2 data-number="11.1" class="anchored" data-anchor-id="sec-fundamentals"><span class="header-section-number">11.1</span> Fundamentals</h2>
<p>In this last part of the course, we will consider <em>boundary problems (BVPs)</em> for ODEs, specifically second-order ODEs. Here, in contrast to initial value problems, one does not specify the value of the function <span class="math inline">\(y\)</span> <em>and its derivative</em> at the left-hand side of the interval in question. Rather, one fixes the value of <span class="math inline">\(y(x)\)</span> at both the left- and the right-hand side. The BVP we will consider throughout is</p>
<p><span id="eq-bvpdef"><span class="math display">\[
y''(x) = f(x,y(x),y'(x)),  \quad a \leq x \leq b, \quad y(a) = \alpha, \; y(b) = \beta,
\tag{11.1}\]</span></span></p>
<p>where <span class="math inline">\(f: [a,b] \times \mathbb{R}^2 \to \mathbb{R}\)</span> and <span class="math inline">\(\alpha,\beta \in \mathbb{R}\)</span>.</p>
<p>Boundary value problems for first-order ODEs are not meaningful, so we need to consider at least ODEs of second order. One can as well formulate BVPs for higher-order ODEs, for systems of ODEs, or by specifying the derivative <span class="math inline">\(y'\)</span> at the boundary rather than the function <span class="math inline">\(y\)</span> itself. We will however not treat these cases here.</p>
<p>Our first question is whether a unique solution of <a href="#eq-bvpdef" class="quarto-xref">Eq.&nbsp;<span>11.1</span></a> exists, before approximating it numerically. This question turns out to be more delicate than with IVPs. We first consider a few examples.</p>
<div id="exm-bvpex1" class="theorem example">
<p><span class="theorem-title"><strong>Example 11.1</strong></span> Let us consider the very simple BVP <span id="eq-bvpex1"><span class="math display">\[
y'' = y,  \quad 0 \leq x \leq 1, \quad y(0) = y(1) = 1.
\tag{11.2}\]</span></span> The ODE <span class="math inline">\(y''=y\)</span> itself (disregarding the boundary conditions for a moment) clearly has the two solutions <span class="math inline">\(y(x)=e^x\)</span> and <span class="math inline">\(y(x)=e^{-x}\)</span>. From the theory of linear ODEs, one knows then that the general solution of the ODE is <span class="math display">\[
y(x) = c e^x + de^{-x},\quad c,d \in \mathbb{R}.
\]</span> That is, every solution of <span class="math inline">\(y''=y\)</span> has this form. Now inserting the boundary conditions, we have <span class="math display">\[
\begin{aligned}
   1 = c e^0 + d e^0 = c + d \quad &amp;\Leftrightarrow \quad d = 1-c,
\\
\label{eq:cdsecond}
   1 = c e^1 + d e^{-1} = ce + \frac{d}{e} \quad &amp;\Leftrightarrow \quad  1
     = ce + \frac{1-c}{e} = c(e-\frac{1}{e}) + \frac{1}{e}.
\end{aligned}
\]</span> From <span class="quarto-unresolved-ref">?eq-cdsecond</span>, we find that the boundary conditions are satisfied if and only if <span class="math display">\[
1 - \frac{1}{e} = c(e-\frac{1}{e}) \quad \Leftrightarrow \quad
  c = \frac{e-1}{e^2-1} = \frac{1}{e+1},
\]</span> of which we compute <span class="math inline">\(d = 1-c = \frac{e}{e+1}\)</span>. That means, the function <span class="math display">\[
y(x) = \frac{e^x}{e+1} + \frac{e^{1-x}}{e+1}
\]</span> is a solution of the BVP <a href="#eq-bvpex1" class="quarto-xref">Eq.&nbsp;<span>11.2</span></a>, and by our computation, it is the <em>only</em> solution of the BVP. In short, <a href="#eq-bvpex1" class="quarto-xref">Eq.&nbsp;<span>11.2</span></a> has a unique solution.</p>
</div>
<div id="exm-bvpex2" class="theorem example">
<p><span class="theorem-title"><strong>Example 11.2</strong></span> Now let us consider a slightly modified BVP, <span id="eq-bvpex2"><span class="math display">\[
y'' = -y,  \quad 0 \leq x \leq 2 \pi, \quad y(0) = y(2\pi) = 1.
\tag{11.3}\]</span></span></p>
<p>Again, from the theory of linear ODEs, one knows that the general solution of the ODE (disregarding the boundary conditions) is</p>
<p><span id="eq-sincossol"><span class="math display">\[
   y(x) = c \cos(x)+ d \sin(x),\quad c,d \in \mathbb{R}.
\tag{11.4}\]</span></span> The boundary conditions demand that <span class="math display">\[
1=y(0) = c \cos(0) + d \sin(0) = c \Leftrightarrow c=1,\quad
\text{and likewise }
   1=y(2\pi) = c  \Leftrightarrow c=1.
\]</span> However, the choice of <span class="math inline">\(d\)</span> does not affect the boundary conditions! In fact, any function of the form <span class="math display">\[
y(x) = \cos(x)+ d \sin(x),\quad d \in \mathbb{R}
\]</span> solves the BVP <a href="#eq-bvpex2" class="quarto-xref">Eq.&nbsp;<span>11.3</span></a>. This BVP has <em>many</em> solutions.</p>
</div>
<div id="exm-bvpex3" class="theorem example">
<p><span class="theorem-title"><strong>Example 11.3</strong></span> Finally, consider another slight modification of our example:</p>
<p><span id="eq-bvpex3"><span class="math display">\[
y'' = -y,  \quad 0 \leq x \leq 2 \pi, \quad y(0) = 0, \; y(2\pi) = 1.
\tag{11.5}\]</span></span></p>
<p>Again, the general solution of the ODE is given by <a href="#eq-sincossol" class="quarto-xref">Eq.&nbsp;<span>11.4</span></a>. However, now our boundary conditions demand that <span class="math display">\[
0=y(0) = c ,\quad
\text{and }
   1=y(2\pi) = c,
\]</span> which gives us a contradiction. In other words, the BVP <a href="#eq-bvpex3" class="quarto-xref">Eq.&nbsp;<span>11.5</span></a> has <em>no solution</em>.</p>
</div>
<section id="a-criterion" class="level3" data-number="11.1.1">
<h3 data-number="11.1.1" class="anchored" data-anchor-id="a-criterion"><span class="header-section-number">11.1.1</span> A criterion</h3>
<p>We need a criterion that guarantees that a BVP has a unique solution. As is clear from the above examples, the Lipschitz condition which we previously considered does not suffice. The following theorem <span class="citation" data-cites="Burden_Faires">(<a href="references.html#ref-Burden_Faires" role="doc-biblioref">Burden and Faires 2010</a> Theorem 11.1)</span>, which we quote here without proof, gives a sufficient (not a necessary) criterion.</p>
<div id="thm:bvpunique" class="theorem">
<p><strong>Theorem 9</strong>. <em>Suppose that <span class="math inline">\(f:[a,b] \times \mathbb{R}^2 \to \mathbb{R}\)</span> is continuous, that the partial derivatives<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> <span class="math inline">\(\partial f(x,y,y') / \partial y\)</span> and <span class="math inline">\(\partial f(x,y,y') / \partial y'\)</span> exist and are continuous, and that</em></p>
<ol type="1">
<li><p><em><span class="math inline">\(\dfrac{\partial f}{\partial y}(x,y,y') &gt; 0\)</span> for all <span class="math inline">\(x \in [a,b]\)</span>, <span class="math inline">\(y,y' \in \mathbb{R}\)</span>,</em></p></li>
<li><p><em><span class="math inline">\(\Big\lvert \dfrac{\partial f}{\partial y'}(x,y,y') \Big\rvert \leq M\)</span> for all <span class="math inline">\(x \in [a,b]\)</span>, <span class="math inline">\(y,y' \in \mathbb{R}\)</span>,</em></p></li>
</ol>
<p>*with a constant <span class="math inline">\(M&gt;0\)</span>. Then, the boundary value problem</p>
<p><span id="eq-bvprepeat"><span class="math display">\[
y''(x) = f(x,y(x),y'(x)),  \quad a \leq x \leq b, \quad y(a) = \alpha, \; y(b) = \beta
\tag{11.6}\]</span></span></p>
<p>has a unique solution for any <span class="math inline">\(\alpha,\beta \in \mathbb{R}\)</span>.*</p>
</div>
<p>Briefly speaking, in order to obtain a unique solution, it suffices that <span class="math inline">\(\partial f / \partial y\)</span> is <em>positive</em> and <span class="math inline">\(\partial f / \partial y'\)</span> is <em>bounded</em>. The former condition was violated in our examples <a href="#eq-bvpex2" class="quarto-xref">Eq.&nbsp;<span>11.3</span></a> and <a href="#eq-bvpex3" class="quarto-xref">Eq.&nbsp;<span>11.5</span></a>.</p>
</section>
<section id="linear-odes" class="level3" data-number="11.1.2">
<h3 data-number="11.1.2" class="anchored" data-anchor-id="linear-odes"><span class="header-section-number">11.1.2</span> Linear ODEs</h3>
<p>We will often consider the simplified, but still very relevant, case of boundary value problems for <em>linear</em> ODEs. By this, we mean a BVP of the form <span id="eq-bvplin"><span class="math display">\[
y''(x) = p(x) y'(x) + q(x) y(x) + r(x),  \quad a \leq x \leq b, \quad y(a) = \alpha, \; y(b) = \beta,
\tag{11.7}\]</span></span></p>
<p>where <span class="math inline">\(p,q,r: [a,b]\to\mathbb{R}\)</span>. A uniqueness criterion for these can be given as follows.</p>
<div id="thm:bvplinunique" class="theorem">
<p><strong>Theorem 10</strong>. <em>Suppose that <span class="math inline">\(p,q,r \in \mathcal{C}^0([a,b])\)</span>, and that <span class="math inline">\(q(x)&gt;0\)</span> for all <span class="math inline">\(x \in [a,b]\)</span>. Then, the boundary value problem <a href="#eq-bvplin" class="quarto-xref">Eq.&nbsp;<span>11.7</span></a> has a unique solution for any <span class="math inline">\(\alpha,\beta \in \mathbb{R}\)</span>.</em></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span><em>Proof.</em> This follows immediately from Theorem&nbsp;<a href="#thm:bvpunique" data-reference-type="ref" data-reference="thm:bvpunique">9</a>: In the present case, <span class="math display">\[
f(x,y,y') =  p(x) y' + q(x) y + r(x),
\quad \frac{\partial f(x,y,y'}{\partial y} = q(x),
\quad \frac{\partial f(x,y,y'}{\partial y'} = p(x),
\]</span> and continuous functions on a bounded interval are always bounded.&nbsp;◻</p>
</div>
</section>
<section id="approximation-methods" class="level3" data-number="11.1.3">
<h3 data-number="11.1.3" class="anchored" data-anchor-id="approximation-methods"><span class="header-section-number">11.1.3</span> Approximation methods</h3>
<p>In the following sections, we will discuss three very different approximation methods for the solutions of BVPs:</p>
<ul>
<li><p>the <em>Shooting Method</em>, which makes use of the techniques for IVPs which we discussed in Part&nbsp;<a href="#par:ivp" data-reference-type="ref" data-reference="par:ivp"></a> of the course,</p></li>
<li><p>the <em>Finite Difference Method</em>, which approximates the derivatives of the ODE with difference quotients,</p></li>
<li><p>the <em>Rayleigh-Ritz Method</em>, which reformulates the BVP as a minimization problem of a certain integral.</p></li>
</ul>
<p>The Finite Difference Method and the Rayleigh-Ritz method are particularly important: first, because they are adapted to the nature of boundary value problems; second, because they have generalizations to the approximation theory of partial differential equations.</p>
</section>
</section>
<section id="the-shooting-method" class="level2" data-number="11.2">
<h2 data-number="11.2" class="anchored" data-anchor-id="the-shooting-method"><span class="header-section-number">11.2</span> The Shooting Method</h2>
<p>As the first approximation method for the solutions of BVPs, we will discuss the <em>Shooting Method</em>. It works by transforming the boundary value problem into an initial value problem, and then using our known approximation methods for BVPs.</p>
<section id="the-idea" class="level3" data-number="11.2.1">
<h3 data-number="11.2.1" class="anchored" data-anchor-id="the-idea"><span class="header-section-number">11.2.1</span> The idea</h3>
<p>We will consider the BVP <span id="eq-bvpshoot"><span class="math display">\[
y''(x) = f(x,y(x),y'(x)),  \quad a \leq x \leq b, \quad y(a) = \alpha, \; y(b) = \beta.
\tag{11.8}\]</span></span></p>
<p>For applying our approximation methods for IVPs to the differential equation, we are missing one initial value, namely for <span class="math inline">\(y'(a)\)</span>.</p>
<p>Let us, for the moment, just pick <em>some</em> fixed <span class="math inline">\(\gamma \in \mathbb{R}\)</span>, and then consider the initial value problem <span id="eq-ivpshoot"><span class="math display">\[
  y_\gamma''(x) = f(x,y_\gamma(x),y_\gamma'(x)),  \quad a \leq x \leq b, \quad y_\gamma(a) = \alpha, \; y_\gamma'(a) = \gamma.
\tag{11.9}\]</span></span></p>
<p>(The solution <span class="math inline">\(y_\gamma(x)\)</span> will depend on our choice of <span class="math inline">\(\gamma\)</span>, and we indicate this with the <span class="math inline">\(\gamma\)</span> subscript.) We can solve the IVP <a href="#eq-ivpshoot" class="quarto-xref">Eq.&nbsp;<span>11.9</span></a> with one of our known approximation methods. This will yield an approximation value <span class="math inline">\(w_N \approx y_\gamma(b)\)</span>. Now we can compare whether our choice of <span class="math inline">\(\gamma\)</span> was reasonable: Namely, we can see whether <span class="math inline">\(w_N \approx \beta\)</span>, or how far <span class="math inline">\(w_N\)</span> is away from <span class="math inline">\(\beta\)</span>. Depending on this result, we adjust our value <span class="math inline">\(\gamma\)</span>, and run the approximation method for <a href="#eq-ivpshoot" class="quarto-xref">Eq.&nbsp;<span>11.9</span></a> again. We repeat this until <span class="math inline">\(w_N \approx \beta\)</span> to a reasonable precision; then the <span class="math inline">\(w_j\)</span> will approximate <span class="math inline">\(y(x_j)\)</span>, where <span class="math inline">\(y\)</span> is the solution of the BVP <a href="#eq-bvpshoot" class="quarto-xref">Eq.&nbsp;<span>11.8</span></a>.</p>
</section>
<section id="systematic-approach" class="level3" data-number="11.2.2">
<h3 data-number="11.2.2" class="anchored" data-anchor-id="systematic-approach"><span class="header-section-number">11.2.2</span> Systematic Approach</h3>
<p>The open point is how to choose the value <span class="math inline">\(\gamma\)</span>. Of course, we want a systematic (i.e., algorithmic) way to find the optimum value.</p>
<p>To formalize this, let us consider the map <span class="math display">\[
g: \mathbb{R} \to \mathbb{R}, \; \gamma \mapsto y_\gamma(b),
\]</span> where <span class="math inline">\(y_\gamma(x)\)</span> is the exact solution of the IVP <a href="#eq-ivpshoot" class="quarto-xref">Eq.&nbsp;<span>11.9</span></a>. We already have methods to compute <span class="math inline">\(g\)</span> approximately (by using approximation methods for IVPs). We need to find <span class="math inline">\(\gamma\)</span> such that <span class="math inline">\(y_{ \gamma}(x)=\beta\)</span>, i.e., such that</p>
<p><span id="eq-geq"><span class="math display">\[
   g( \gamma) = \beta.
\tag{11.10}\]</span></span> In other words, we need to find an (approximate) solution to the equation <a href="#eq-geq" class="quarto-xref">Eq.&nbsp;<span>11.10</span></a>. We will consider two cases:</p>
<p>In the simpler case, <span class="math inline">\(g\)</span> is a <em>linear</em> function, i.e., <span class="math inline">\(g(\gamma)=m\gamma + c\)</span>. In this case, <a href="#eq-geq" class="quarto-xref">Eq.&nbsp;<span>11.10</span></a> can be solved explicitly (once <span class="math inline">\(m\)</span> and <span class="math inline">\(c\)</span> are known), namely</p>
<p><span id="eq-shootlinsol"><span class="math display">\[
   \gamma = \frac{\beta - c}{m}.
\tag{11.11}\]</span></span> It remains to determine the constants <span class="math inline">\(m\)</span> and <span class="math inline">\(c\)</span>.</p>
<p>More generally, <span class="math inline">\(g\)</span> can be a <em>nonlinear</em> function, and in this case we need to solve <a href="#eq-geq" class="quarto-xref">Eq.&nbsp;<span>11.10</span></a> numerically. We will use Newton’s method to that end. That is, we consider a sequence <span class="math inline">\(\gamma_k\)</span>, recursively defined by</p>
<p><span id="eq-shootnewton"><span class="math display">\[
   \gamma_k := \gamma_{k-1} - \frac{g(\gamma_{k-1})-\beta}{g'(\gamma_{k-1})},
\tag{11.12}\]</span></span></p>
<p>which is expected to converge to the desired value <span class="math inline">\(\gamma\)</span>. To that end, it remains to compute the derivative <span class="math inline">\(g'\)</span> of the map <span class="math inline">\(g\)</span>.</p>
</section>
<section id="linear-shooting" class="level3" data-number="11.2.3">
<h3 data-number="11.2.3" class="anchored" data-anchor-id="linear-shooting"><span class="header-section-number">11.2.3</span> Linear Shooting</h3>
<p>Let us first consider the linear case. Not very surprisingly, this arises when the underlying ODE is linear. That is, let us assume that our BVP is of the form <span id="eq-bvplinshoot"><span class="math display">\[
y''(x) = p(x) y'(x) + q(x) y(x) + r(x),  \quad a \leq x \leq b, \quad y(a) = \alpha, \; y(b) = \beta,
\tag{11.13}\]</span></span></p>
<p>with <span class="math inline">\(p,q,r\)</span> being continuous functions on <span class="math inline">\([a,b]\)</span>.</p>
<p>It turns out to be convenient to consider <em>two</em> related IVPs, neither of which involves the value <span class="math inline">\(\gamma\)</span>: <span class="math display">\[
\begin{aligned}
\label{eq:ivpshooty0}
y_0''(x) &amp;= p(x) y_0'(x) + q(x) y_0(x) + r(x),  \quad &amp;a \leq x \leq b, &amp;&amp; y_0(a) &amp;= \alpha, &amp; y_0'(a) &amp;= 0;
\\
\label{eq:ivpshootz}
z'' &amp;= p(x) z'(x) + q(x) z(x) ,  &amp; a \leq x \leq b, &amp;&amp; z(a) &amp;= 0, &amp; z'(a) &amp;= 1.
\end{aligned}
\]</span> Using their exact solutions <span class="math inline">\(y_0(x)\)</span> and <span class="math inline">\(z(x)\)</span>, we can define <span id="eq-yglin"><span class="math display">\[
  y_\gamma(x) := y_0(x) + \gamma z(x);
\tag{11.14}\]</span></span> and by adding <span class="quarto-unresolved-ref">?eq-ivpshooty0</span> and <span class="quarto-unresolved-ref">?eq-ivpshootz</span>, we see that this <span class="math inline">\(y_\gamma\)</span> is the (unique) solution of the IVP <a href="#eq-ivpshoot" class="quarto-xref">Eq.&nbsp;<span>11.9</span></a>.</p>
<p>The solutions <span class="math inline">\(y_0(x)\)</span> and <span class="math inline">\(z(x)\)</span> can be found (approximately) by our known methods from Part&nbsp;<a href="#par:ivp" data-reference-type="ref" data-reference="par:ivp"></a>. We can then compute the correct value of <span class="math inline">\(\gamma\)</span> for our boundary value problem, as indicated in <a href="#eq-shootlinsol" class="quarto-xref">Eq.&nbsp;<span>11.11</span></a>: <span id="eq-getgammalin"><span class="math display">\[
     \gamma = \frac{\beta - y_0(b)}{z(b)}.
\tag{11.15}\]</span></span> Re-inserting this value <span class="math inline">\(\gamma\)</span> into <a href="#eq-yglin" class="quarto-xref">Eq.&nbsp;<span>11.14</span></a>, we have found the (approximate) solution of the BVP.</p>
<div class="algorithm">
<div class="algorithmic">
<p>boundary values <span class="math inline">\(\alpha,\beta\)</span>; number of Runge-Kutta steps <span class="math inline">\(N\)</span> <span class="math inline">\(F :=\; (x,\mathbf{u}) \mapsto (u ^{(2)},p(x) u ^{(2)} + q(x) u ^{(1)} + r(x))\)</span> Rewrite and solve IVP for <span class="math inline">\(y_0\)</span> <span class="math inline">\(\mathbf{y}:=\)</span> <span class="math inline">\(\mathbf{y}= ( \mathbf{y}_0,\ldots, \mathbf{y}_N)\)</span>, each <span class="math inline">\(\mathbf{y}_j\)</span> is a 2-vector <span class="math inline">\(G :=\; (x,\mathbf{u}) \mapsto (u ^{(2)},p(x) u ^{(2)} + q(x) u ^{(1)})\)</span> Rewrite and solve IVP for <span class="math inline">\(z\)</span> <span class="math inline">\(\mathbf{z}:=\)</span> <span class="math inline">\(\mathbf{z}= ( \mathbf{z}_0,\ldots, \mathbf{z}_N)\)</span>, each <span class="math inline">\(\mathbf{z}_j\)</span> is a 2-vector <span class="math inline">\(\gamma := \dfrac{\beta - y_N ^{(1)} }{z_N ^{(1)}}\)</span> <span class="math inline">\(w_i := y_i ^{(1)} + \gamma z_i ^{(1)}\)</span> (<span class="math inline">\(w_{0},\ldots,w_{N}\)</span>)</p>
</div>
</div>
<p>Algorithm&nbsp;<a href="#alg:shootlin" data-reference-type="ref" data-reference="alg:shootlin">[alg:shootlin]</a> summarizes the Linear Shooting Method. We first rewrite the IVP <span class="quarto-unresolved-ref">?eq-ivpshooty0</span> for <span class="math inline">\(y_0\)</span> as a system of two first-order ODEs, and approximate its solution (lines 2–3). For concreteness’ sake, we choose the classical Runge-Kutta method for the approximation. We do likewise with the IVP <span class="quarto-unresolved-ref">?eq-ivpshootz</span> for <span class="math inline">\(z\)</span>, in lines 4–5. Now we can compute the correct value of <span class="math inline">\(\gamma\)</span> (line 6), and combine the approximations for <span class="math inline">\(y_0\)</span> and <span class="math inline">\(z\)</span> into the approximation of the BVP solution (lines 7–9).</p>
</section>
<section id="nonlinear-shooting" class="level3" data-number="11.2.4">
<h3 data-number="11.2.4" class="anchored" data-anchor-id="nonlinear-shooting"><span class="header-section-number">11.2.4</span> Nonlinear Shooting</h3>
<p>Now let us turn to the nonlinear case, i.e., to a generic BVP of the form <span id="eq-bvpshootnonlin"><span class="math display">\[
y''(x) = f(x,y(x),y'(x)),  \quad a \leq x \leq b, \quad y(a) = \alpha, \; y(b) = \beta.
\tag{11.16}\]</span></span></p>
<p>As said before, we will use Newton’s method for finding the correct value of <span class="math inline">\(\gamma\)</span>. That means, we need to compute the sequence <span class="math inline">\((\gamma_k)\)</span> given by <span id="eq-gammastep"><span class="math display">\[
  \gamma_k := \gamma_{k-1} - \frac{g(\gamma_{k-1})-\beta}{g'(\gamma_{k-1})}.
\tag{11.17}\]</span></span></p>
<p>To that end, we need to know how to compute <span class="math inline">\(g(\gamma)\)</span> and <span class="math inline">\(g'(\gamma)\)</span> numerically.</p>
<p>Here finding <span class="math inline">\(g(\gamma)\)</span> is not difficult: We have <span class="math inline">\(g(\gamma)=y_\gamma(b)\)</span>, where <span class="math inline">\(y_\gamma\)</span> is the solution of the IVP</p>
<p><span id="eq-ivpgamma"><span class="math display">\[
  y_\gamma''(x) = f(x,y_\gamma(x),y_\gamma'(x)),  \quad a \leq x \leq b, \quad y_\gamma(a) = \alpha, \; y_\gamma'(a) = \gamma.
\tag{11.18}\]</span></span></p>
<p>We can approximate this solution numerically with any of our known methods – say, classical Runge-Kutta – and thus obtain an approximation of <span class="math inline">\(g(\gamma)\)</span>.</p>
<p>However, for its derivative <span class="math inline">\(g'\)</span>, the right approach is much less obvious. We need to compute <span class="math display">\[
g'(\gamma) = \frac{\partial}{\partial \gamma} y_\gamma(x)\Big|_{x=b} .
\]</span> In order to find this value, we differentiate <a href="#eq-ivpgamma" class="quarto-xref">Eq.&nbsp;<span>11.18</span></a> by <span class="math inline">\(\gamma\)</span>, using the chain rule.</p>
<p><span id="eq-ivpgammap"><span class="math display">\[
\; \frac{\partial y_\gamma'}{\partial \gamma}(a) = 1.
\tag{11.19}\]</span></span> This does not determine <span class="math inline">\(\partial y_\gamma/\partial \gamma\)</span> directly. However, it gives us a second-order IVP from which the derivative can be determined.</p>
<p>To make this more concrete, let us use the substitution <span class="math display">\[
u ^{(1)} = y_\gamma, \quad
   u ^{(2)} = y_\gamma', \quad
   u ^{(3)} = \frac{\partial y_\gamma}{\partial \gamma}, \quad
   u ^{(4)} = \frac{\partial y_\gamma'}{\partial \gamma}.
\]</span> We can then rewrite <a href="#eq-ivpgamma" class="quarto-xref">Eq.&nbsp;<span>11.18</span></a> <em>and</em> <a href="#eq-ivpgammap" class="quarto-xref">Eq.&nbsp;<span>11.19</span></a> into an IVP for 4 first-order ODEs:</p>
<p><span id="eq-ivpu4"><span class="math display">\[
     \end{pmatrix} .
\tag{11.20}\]</span></span> From this IVP, which can be treated, e.g., with the classical Runge-Kutta method, we can now read off <span class="math display">\[
g(\gamma) = u ^{(1)}(b), \quad g'(\gamma) = u ^{(3)}(b).
\]</span> This finally allow us to compute the Newton step <a href="#eq-gammastep" class="quarto-xref">Eq.&nbsp;<span>11.17</span></a>.</p>
<div class="algorithm">
<div class="algorithmic">
<p>boundary values <span class="math inline">\(\alpha,\beta\)</span>; start value <span class="math inline">\(\gamma_0\)</span>; number of Runge-Kutta steps <span class="math inline">\(N\)</span>; tolerance <span class="math inline">\(T\)</span>; maximum number of Newton iterations <span class="math inline">\(M\)</span> <span class="math inline">\(F:=  (x,\mathbf{u}) \mapsto \big(u ^{(2)},  f(x,u ^{(1)},u ^{(2)}), u ^{(4)} ,
   \frac{\partial f}{\partial y}(x,u ^{(1)},u ^{(2)}) \, u ^{(3)} +\frac{\partial
    f}{\partial y'}(x,u ^{(1)},u ^{(2)}) \, u ^{(4)} \big)\)</span> <span class="math inline">\(\gamma := \gamma_0\)</span>; <span class="math inline">\(k:=0\)</span> <span id="ali:nlsnewtonstart" label="ali:nlsnewtonstart"></span> <span class="math inline">\(\mathbf{w}:=\)</span> here <span class="math inline">\(\mathbf{w}= ( \mathbf{w}_0,\ldots, \mathbf{w}_N)\)</span>, each <span class="math inline">\(\mathbf{w}_j\)</span> is a 4-vector <span class="math inline">\(v := \dfrac{w_{N} ^{(1)}-\beta}{w_{N} ^{(3)}}\)</span>; <span class="math inline">\(\gamma := \gamma - v\)</span> <strong>if</strong> <span class="math inline">\(|v|&lt;T\)</span> <strong>then</strong> <strong>break</strong> <strong>end if</strong> <span class="math inline">\(k:=k+1\)</span> <strong>if</strong> <span class="math inline">\(k&gt;M\)</span> <strong>then</strong> <strong>exception</strong> (“Too many iterations”) <strong>end if</strong> <span id="ali:nlsnewtonend" label="ali:nlsnewtonend"></span> (<span class="math inline">\(w_{0} ^{(1)},\ldots,w_{N} ^{(1)}\)</span>)</p>
</div>
</div>
<p>Let us summarize the Nonlinear Shooting Method in Algorithm&nbsp;<a href="#alg:shootnonlin" data-reference-type="ref" data-reference="alg:shootnonlin">[alg:shootnonlin]</a>. Its structure is of the now well-known Newton iteration type, with the Newton loop in lines <a href="#ali:nlsnewtonstart" data-reference-type="ref" data-reference="ali:nlsnewtonstart">[ali:nlsnewtonstart]</a>–<a href="#ali:nlsnewtonend" data-reference-type="ref" data-reference="ali:nlsnewtonend">[ali:nlsnewtonend]</a>. In each iteration of the loop, we solve the IVP <a href="#eq-ivpu4" class="quarto-xref">Eq.&nbsp;<span>11.20</span></a> with the classical Runge-Kutta method. We then pick the approximation values at the rightmost mesh point and compute the next <span class="math inline">\(\gamma\)</span> value from them. The usual methods of breaking the Newton loop are in place - either after sufficient precision is reached, or (with an error) after too many steps have been taken.</p>
</section>
</section>
<section id="sec-fdm" class="level2" data-number="11.3">
<h2 data-number="11.3" class="anchored" data-anchor-id="sec-fdm"><span class="header-section-number">11.3</span> The Finite Difference Method</h2>
<p>The <em>Finite Difference Method (FDM)</em> is another, very different method of approximating the solution of the BVP <span id="eq-bvpfdm"><span class="math display">\[
y''(x) = f(x,y(x),y'(x)),  \quad a \leq x \leq b, \quad y(a) = \alpha, \; y(b) = \beta.
\tag{11.21}\]</span></span></p>
<p>This method does not refer back to our approximation methods for IVPs, but is adapted directly to BVPs.</p>
<section id="the-idea-1" class="level3" data-number="11.3.1">
<h3 data-number="11.3.1" class="anchored" data-anchor-id="the-idea-1"><span class="header-section-number">11.3.1</span> The idea</h3>
<p>Similar to before, we divide our interval with equally spaced mesh points, <span class="math inline">\(x_0,\ldots,x_{N+1}\)</span>, where <span class="math inline">\(x_0=a\)</span> and <span class="math inline">\(x_{N+1}=b\)</span>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> As before, we want to approximate <span class="math inline">\(y(x_i)\)</span> with a value <span class="math inline">\(w_i\)</span> (<span class="math inline">\(i=1,\ldots,N\)</span>).</p>
<p>The main idea of the FDM is to approximate the derivatives <span class="math inline">\(y'(x_i)\)</span> and <span class="math inline">\(y''(x_i)\)</span> with difference quotients (“finite differences”). For example, we could use <span id="eq-diffquot"><span class="math display">\[
   y'(x_i) \approx \frac{w_{i+1}-w_i}{h},
\tag{11.22}\]</span></span> but we will see an even better choice later. A similar approximation will need to be found for <span class="math inline">\(y''(x_i)\)</span>.</p>
<p>In this way, the ODE is transformed into a system of equations for <span class="math inline">\(w_1,\ldots,w_N\)</span>, and the boundary conditions are expressed by <span class="math inline">\(w_0=\alpha\)</span>, <span class="math inline">\(w_{N+1}=\beta\)</span>.</p>
</section>
<section id="centred-difference-formulas" class="level3" data-number="11.3.2">
<h3 data-number="11.3.2" class="anchored" data-anchor-id="centred-difference-formulas"><span class="header-section-number">11.3.2</span> Centred difference formulas</h3>
<p>As a first step, we will derive an improved version of the difference quotient approximation <a href="#eq-diffquot" class="quarto-xref">Eq.&nbsp;<span>11.22</span></a>, in which the error term was of order <span class="math inline">\(O(h)\)</span>. Let us assume that the solution <span class="math inline">\(y(x)\)</span> of the BVP has three continuous derivatives. We write down second-order Taylor expansions of <span class="math inline">\(y(x_{i+1})\)</span> and <span class="math inline">\(y(x_{i-1})\)</span>, cf.&nbsp;Theorem&nbsp;<a href="#thm:taylor1d" data-reference-type="ref" data-reference="thm:taylor1d">12</a>: <span class="math display">\[
\begin{aligned}
{4}
\label{eq:cd1}
  y(x_{i+1}) \;&amp;=&amp;\; y(x_i+h) \;&amp;=&amp;\; y(x_i) + h y'(x_i) + \frac{h^2}{2} y''(x_i)
  + \frac{h^3}{6} y'''(\xi_+);
\\
\label{eq:cd2}
  y(x_{i-1}) &amp;=&amp; y(x_i-h) &amp;=&amp; y(x_i) - h y'(x_i) + \frac{h^2}{2} y''(x_i)
- \frac{h^3}{6} y'''(\xi_-)
\end{aligned}
\]</span> with some <span class="math inline">\(\xi_+ \in [x_i,x_{i+1}]\)</span> and <span class="math inline">\(\xi_- \in [x_{i-1},x_{i}]\)</span>. Subtracting <span class="quarto-unresolved-ref">?eq-cd2</span> from <span class="quarto-unresolved-ref">?eq-cd1</span>, we obtain <span class="math display">\[
y(x_{i+1}) - y(x_{i-1}) = 2 h y'(x_i) + \frac{h^3}{6}
\underbrace{\big(
   y'''(\xi_+) + y'''(\xi_-)
\big)}_{
  2 y'''(\xi)
}.
\]</span> Here <span class="math inline">\(\xi \in [x_{i-1},x_{i+1}]\)</span> is some point obtained from the intermediate value theorem. Solving for <span class="math inline">\(y'(x_i)\)</span>, we find</p>
<p><span id="eq-cdyp"><span class="math display">\[
y'(x_i) = \frac{ y(x_{i+1}) - y(x_{i-1}) }{2h} - \frac{h^2}{6} y'''(\xi).
\tag{11.23}\]</span></span></p>
<p>This is known as a <em>centred difference formula</em>. Note that the “error term” here is of order <span class="math inline">\(O(h^2)\)</span> which is better than the <span class="math inline">\(O(h)\)</span> one obtains in <a href="#eq-diffquot" class="quarto-xref">Eq.&nbsp;<span>11.22</span></a>.</p>
<p>We can obtain a similar formula for <span class="math inline">\(y''(x_i)\)</span> as well, using a third-order Taylor expansion of <span class="math inline">\(y\)</span>. See <span class="citation" data-cites="Burden_Faires">(<a href="references.html#ref-Burden_Faires" role="doc-biblioref">Burden and Faires 2010, sec. 4.1</a>, Eq.&nbsp;(4.9))</span> for details. The result is <span id="eq-cdypp"><span class="math display">\[
y''(x_i) = \frac{ y(x_{i+1}) - 2 y(x_i) + y(x_{i-1}) }{h^2} - \frac{h^2}{12} y''''(\xi)
\tag{11.24}\]</span></span></p>
<p>with some <span class="math inline">\(\xi \in [x_{i-1},x_{i+1}]\)</span>.</p>
</section>
<section id="recipe-for-the-finite-difference-method" class="level3" data-number="11.3.3">
<h3 data-number="11.3.3" class="anchored" data-anchor-id="recipe-for-the-finite-difference-method"><span class="header-section-number">11.3.3</span> Recipe for the Finite Difference Method</h3>
<p>We can now formulate an outline of the FDM in our context. Starting from a boundary value problem of the form <a href="#eq-bvpfdm" class="quarto-xref">Eq.&nbsp;<span>11.21</span></a>, we consider the <span class="math inline">\(N\)</span> equations</p>
<p><span id="eq-fdmstart"><span class="math display">\[
   y''(x_i) = f\big(x_i, y(x_i), y'(x_i)\big), \quad  i = 1,\ldots,N.
\tag{11.25}\]</span></span></p>
<p>In order to obtain an approximate solution, we manipulate the equations as follows:</p>
<ul>
<li><p>Replace all occurrences of <span class="math inline">\(y(x_i)\)</span> with <span class="math inline">\(w_i\)</span>.</p></li>
<li><p>Replace all occurrences of <span class="math inline">\(y'(x_i)\)</span> with <span class="math inline">\(\dfrac{w_{i+1}-w_{i-1}}{2h}\)</span>; cf.&nbsp;<a href="#eq:cdyp" data-reference-type="eqref" data-reference="eq:cdyp">[eq:cdyp]</a>.</p></li>
<li><p>Replace all occurrences of <span class="math inline">\(y''(x_i)\)</span> with <span class="math inline">\(\dfrac{w_{i+1}-2 w_i +w_{i-1}}{h^2}\)</span>; cf.&nbsp;<a href="#eq:cdypp" data-reference-type="eqref" data-reference="eq:cdypp">[eq:cdypp]</a>.</p></li>
<li><p>Set <span class="math inline">\(w_0=\alpha\)</span>, <span class="math inline">\(w_{N+1}=\beta\)</span>.</p></li>
</ul>
<p>This will leave us with a system of <span class="math inline">\(N\)</span> equations for the <span class="math inline">\(N\)</span> variables <span class="math inline">\(w_1,\ldots,w_N\)</span>. This equation system can either be linear, in which case we can apply algorithms for solving linear equation systems (see Part A); or it can be nonlinear, in which case we need Newton’s method in several variables (again see Part A) to approximate the solution.</p>
<p>The error order of this approximation scheme is determined by the remainder term in the centred difference formulas, Eqs.&nbsp;<a href="#eq-cdyp" class="quarto-xref">Eq.&nbsp;<span>11.23</span></a> and <a href="#eq-cdypp" class="quarto-xref">Eq.&nbsp;<span>11.24</span></a>; namely, the method is of order <span class="math inline">\(O(h^2)\)</span>. However, we will not prove this here.</p>
</section>
<section id="the-linear-finite-difference-method" class="level3" data-number="11.3.4">
<h3 data-number="11.3.4" class="anchored" data-anchor-id="the-linear-finite-difference-method"><span class="header-section-number">11.3.4</span> The Linear Finite Difference Method</h3>
<p>Let us first apply the recipe to a <em>linear</em> ODE, that is, to a boundary value problem of the form <span id="eq-bvpfdmlin"><span class="math display">\[
y''(x) = p(x)y'(x) + q(x) y(x) + r(x),  \quad a \leq x \leq b, \quad y(a) = \alpha, \; y(b) = \beta.
\tag{11.26}\]</span></span></p>
<p>In this case, Eq.&nbsp;<a href="#eq-fdmstart" class="quarto-xref">Eq.&nbsp;<span>11.25</span></a> reads <span class="math display">\[
y''(x_i) = p(x_i) y'(x_i) + q(x_i) y(x_i) + r(x_i), \quad  i = 1,\ldots,N.
\]</span> By the substitution rules mentioned above, and with the abbreviations <span class="math inline">\(p_i:=p(x_i)\)</span>, <span class="math inline">\(q_i:=q(x_i)\)</span>, <span class="math inline">\(r_i := r(x_i)\)</span>, we get: <span class="math display">\[
\dfrac{w_{i+1}-2 w_i +w_{i-1}}{h^2}
= p_i \dfrac{w_{i+1}-w_{i-1}}{2h} + q_i w_i + r_i, \quad  i = 1,\ldots,N.
\]</span> Multiplying with <span class="math inline">\(h^2\)</span>, and bringing all <span class="math inline">\(w_j\)</span> to the left-hand side, we can rewrite this as <span class="math display">\[
w_{i+1}-2 w_i +w_{i-1} - \frac{h}{2}p_i w_{i+1}
+ \frac{h}{2}p_i w_{i-1} -  h^2 q_i w_i = h^2 r_i,
\]</span> or</p>
<p><span id="eq-fdmlinsys"><span class="math display">\[
  +  w_{i-1} (-1- \frac{h}{2}p_i)  = - h^2 r_i,\quad  i = 1,\ldots,N.
\tag{11.27}\]</span></span></p>
<p>Note here that <span class="math inline">\(w_{i-1}\)</span> may be <span class="math inline">\(w_0\)</span> (if <span class="math inline">\(i=1\)</span>) and <span class="math inline">\(w_{i+1}\)</span> may be <span class="math inline">\(w_{N+1}\)</span> (if <span class="math inline">\(i=N\)</span>). So not all <span class="math inline">\(w_j\)</span> are variables, some need to be replaced with the boundary values <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span>. Keeping this in mind, we can rewrite the equation system <a href="#eq-fdmlinsys" class="quarto-xref">Eq.&nbsp;<span>11.27</span></a> in matrix form: <span class="math display">\[
\begin{gathered}
\underbrace{ \begin{pmatrix}
2+h^2 q_1 &amp; -1+\frac{h}{2} p_1 &amp; 0 &amp; \hdots &amp; 0
\\
-1-\frac{h}{2}p_2 &amp; 2 + h^2 q_2 &amp; -1+\frac{h}{2} p_2 &amp; 0 &amp; \vdots \\
0 &amp; \ddots &amp; \ddots &amp; \ddots &amp; 0\\
\vdots &amp; 0 &amp;  -1-\frac{h}{2}p_{N-1} &amp; 2 + h^2 q_{N-1} &amp; -1+\frac{h}{2}
p_{N-1}\\
0 &amp; \hdots &amp; 0 &amp; -1-\frac{h}{2}p_N &amp; 2 + h^2 q_N   
\end{pmatrix} }_{=:\mathbf{A}}
\mathbf{w}
%
\\
%
=\underbrace{ \begin{pmatrix}
%
-h^2 r_1 + (1+\frac{h}{2}p_1)\alpha  
\\
-h^2 r_2
\\
\vdots
\\
-h^2 r_{N-1}
\\
-h^2 r_N + (1-\frac{h}{2}p_N)\beta  
%
\end{pmatrix} }_{=:\mathbf{b}}
.
%
\end{gathered}
\]</span> The matrix <span class="math inline">\(\mathbf{A}\)</span> is tridiagonal. Therefore, we can use fast algorithms e.g.&nbsp;Crout factorization) in order to solve the linear equation system, and obtain the vector <span class="math inline">\(\mathbf{w}=(w_1,\ldots,w_N)\)</span> in <span class="math inline">\(O(N)\)</span> time. This directly gives us the required approximation of the solution <span class="math inline">\(y(x)\)</span>.</p>
</section>
<section id="the-nonlinear-finite-difference-method" class="level3" data-number="11.3.5">
<h3 data-number="11.3.5" class="anchored" data-anchor-id="the-nonlinear-finite-difference-method"><span class="header-section-number">11.3.5</span> The Nonlinear Finite Difference Method</h3>
<p>Let us now discuss the case of a completely generic, possibly nonlinear ODE. As before, we set out from the <span class="math inline">\(N\)</span> equations in <a href="#eq-fdmstart" class="quarto-xref">Eq.&nbsp;<span>11.25</span></a>. Again we substitute the function <span class="math inline">\(y\)</span> and its derivatives with <span class="math inline">\(w_i\)</span> and their finite differences. However, in absence of more information about the function <span class="math inline">\(f\)</span>, we end up with just <span class="math display">\[
\dfrac{w_{i+1}-2 w_i +w_{i-1}}{h^2} =
   f\Big(x_i, w_i, \dfrac{w_{i+1}-w_{i-1}}{2h} \Big),
   \quad  i = 1,\ldots,N.
\]</span> We can rewrite this in a more convenient form: <span id="eq-Fdef"><span class="math display">\[
   \quad  i = 1,\ldots,N.
\tag{11.28}\]</span></span> Our task is now to solve the nonlinear equation system <span class="math inline">\(\mathbf{F}(\mathbf{w})=0\)</span> for <span class="math inline">\(\mathbf{w}=(w_1,\ldots,w_N)\)</span>, where it is understood that <span class="math inline">\(w_0=\alpha\)</span> and <span class="math inline">\(w_{N+1}=\beta\)</span>.</p>
<p>We will do this with the <span class="math inline">\(N\)</span>-dimensional version of Newton’s method, as discussed in Part A. To that end, we need to compute the Jacobian matrix of <span class="math inline">\(\mathbf{F}\)</span>; that is, we need to compute all the partial derivatives <span class="math inline">\(\partial F ^{(i)}/\partial w ^{(j)}\)</span>. Fortunately, most of these turn out to vanish. We compute from <a href="#eq-Fdef" class="quarto-xref">Eq.&nbsp;<span>11.28</span></a>, <span class="math display">\[
\begin{aligned}
\label{eq:Fder1}
  \frac{\partial F ^{(i)}}{\partial w ^{(i+1)}}
   &amp;= -1  + \frac{h}{2} \frac{\partial f}{\partial y'} \Big(x_i, w_i, \dfrac{w_{i+1}-w_{i-1}}{2h} \Big) \quad &amp;\text{for } i=1,\ldots,N-1,
\\ \label{eq:Fder2}
  \frac{\partial F ^{(i)}}{\partial w ^{(i-1)}}
   &amp;= -1  - \frac{h}{2} \frac{\partial f}{\partial y'} \Big(x_i, w_i, \dfrac{w_{i+1}-w_{i-1}}{2h} \Big) \quad &amp;\text{for } i=2,\ldots,N,
\\ \label{eq:Fder3}
  \frac{\partial F  ^{(i)}}{\partial w ^{(i)}}
   &amp;= \hphantom{-} 2  + h^2 \frac{\partial f}{\partial y} \Big(x_i, w_i, \dfrac{w_{i+1}-w_{i-1}}{2h} \Big) \quad &amp;\text{for } i=1,\ldots,N.
\end{aligned}
\]</span> All other partial derivatives are 0. That is, the Jacobian matrix <span class="math inline">\(\mathbf{J}=\partial \mathbf{F}/\partial\mathbf{w}\)</span> is tridiagonal. This allows us to solve the linear system involved in each step of the Newton iteration very fast.</p>
<p>For doing the Newton iteration, we need a sensible start value for the vector <span class="math inline">\(\mathbf{w}\)</span>. A common choice is to place the points <span class="math inline">\((x_i,w ^{(i)})\)</span> on a straight line from <span class="math inline">\((a,\alpha)\)</span> to <span class="math inline">\((b,\beta)\)</span>: <span class="math display">\[
w ^{(i)}_0 = \alpha + i h \frac{\beta-\alpha}{b-a}.
\]</span></p>
<div class="algorithm">
<div class="algorithmic">
<p>boundary values <span class="math inline">\(\alpha,\beta\)</span>; number of mesh points <span class="math inline">\(N\)</span>, max.&nbsp;Newton iterations <span class="math inline">\(M\)</span> <span class="math inline">\(h := (b-a)/(N+1)\)</span>; <span class="math inline">\(k:=1\)</span> <span class="math inline">\(w ^{(i)} := \alpha + i h \frac{\beta-\alpha}{b-a}\)</span> <span class="math inline">\((i = 1,\ldots,N)\)</span> <span id="ali:fdmnewtonstart" label="ali:fdmnewtonstart"></span> Compute <span class="math inline">\(\mathbf{F}(\mathbf{w})\)</span> and <span class="math inline">\(\mathbf{J}(\mathbf{w})\)</span> Solve <span class="math inline">\(\mathbf{J}(\mathbf{w})\mathbf{v}=\mathbf{F}(\mathbf{w})\)</span> for <span class="math inline">\(\mathbf{v}\)</span> using e.g.&nbsp;Crout factorization <span class="math inline">\(\mathbf{w}:= \mathbf{w}- \mathbf{v}\)</span> <strong>if</strong> <span class="math inline">\(\lVert \mathbf{v} \rVert&lt;T\)</span> <strong>then</strong> <strong>break</strong> <strong>end if</strong> <span class="math inline">\(k:=k+1\)</span> <strong>if</strong> <span class="math inline">\(k&gt;M\)</span> <strong>then</strong> <strong>exception</strong> (“Too many iterations”) <strong>end if</strong> <span id="ali:fdmnewtonend" label="ali:fdmnewtonend"></span> <span class="math inline">\(\mathbf{w}\)</span></p>
</div>
</div>
<p>All that’s left to do is to assemble the algorithm. This is done in Algorithm&nbsp;<a href="#alg:fdmnonlin" data-reference-type="ref" data-reference="alg:fdmnonlin">[alg:fdmnonlin]</a>. The pattern follows our usual approach to Newton’s method.</p>
<p>In each step of the Newton iteration, we need to solve one linear equation system. We can use e.g.&nbsp;the Crout factorization algorithm (Burden and Faires Algorithm 6.7) to this end — this makes use of the fact that the Jacobian is tridiagonal, and allows every Newton step to run in only <span class="math inline">\(O(N)\)</span> time.</p>
</section>
</section>
<section id="sec-rritz" class="level2" data-number="11.4">
<h2 data-number="11.4" class="anchored" data-anchor-id="sec-rritz"><span class="header-section-number">11.4</span> The Rayleigh-Ritz Method</h2>
<p>The third, and radically different, approximation method for BVPs that we will discuss is called the <em>Rayleigh-Ritz method</em>.</p>
<section id="motivation" class="level3" data-number="11.4.1">
<h3 data-number="11.4.1" class="anchored" data-anchor-id="motivation"><span class="header-section-number">11.4.1</span> Motivation</h3>
<p>We start with a brief motivation originating in physics, or in engineering. Consider a beam of length <span class="math inline">\(L\)</span>, fixed at both end points, which is deflected under its own weight. Denote with <span class="math inline">\(y(x)\)</span>, <span class="math inline">\(0 \leq x \leq L\)</span>, the deflection of the beam at point <span class="math inline">\(x\)</span>. There are two complementary approaches of finding <span class="math inline">\(y(x)\)</span>.</p>
<p>a) One may think of the problem in terms of a <em>local equilibrium of forces</em>. Several types of forces act at each point <span class="math inline">\(x\)</span> of the beam - the gravitational force (downwards), but also forces relating to the elasticity of the beam, which pull the deflected beam upwards. In the rest position of the beam, the sum of these forces will be 0 at each point. This leads us to an ODE of the form <span class="math inline">\(y''(x) = f(x,y(x),y'(x))\)</span> (we do not specify the function <span class="math inline">\(f\)</span> further here). The ends of the beam are fixed, so we are enforcing <span class="math inline">\(y(0)=y(L)=0\)</span>. Thus, we are dealing with a boundary value problem for an ODE.</p>
<p>b) Particularly in physics, one alternatively thinks of the situation as an <em>energy minimization problem</em>. The total energy of the beam will consist of its energy in the gravitational field, and of the energy associated with elasticity. We can associate with each point of the beam an <em>energy density</em>, <span class="math inline">\(\lambda\)</span>, which depends on the deflection <span class="math inline">\(y\)</span>. It will roughly have the form <span class="math display">\[
\lambda  = c y'(x)^2 - d y(x) + \ldots
\]</span> with constants <span class="math inline">\(c\)</span> and <span class="math inline">\(d\)</span>, where the term proportional to <span class="math inline">\((y'(x))^2\)</span> comes from elasticity, and the term proportional to <span class="math inline">\(y\)</span> from gravitation. (We are not interested in the form of <span class="math inline">\(\lambda\)</span> in detail here). The rest position of the beam is now found by the requirement that the <em>total energy</em> of the beam is minimal. This total energy is found by integrating <span class="math inline">\(\lambda\)</span> over the length of the beam:</p>
<p><span id="eq-eint"><span class="math display">\[
   E = \int_0^L \lambda (y(x),y'(x)) \, \mathrm{d}x
\tag{11.29}\]</span></span> So we are left with the problem of finding the function <span class="math inline">\(y(x)\)</span> that minimizes the integral <a href="#eq-eint" class="quarto-xref">Eq.&nbsp;<span>11.29</span></a>, while satisfying the boundary conditions <span class="math inline">\(y(0)=y(L)=0\)</span>.</p>
<p>This example – which is added here only for illustration – raises an interesting mathematical question: Can we, under more general conditions, rewrite a boundary value problem for an ODE equivalently as a minimization problem for an integral expression? If yes, we can try to approximate the integral expression numerically (rather than the BVP), which may offer new options for numerical methods.</p>
</section>
<section id="equivalence-of-bvps-with-minimization-problems" class="level3" data-number="11.4.2">
<h3 data-number="11.4.2" class="anchored" data-anchor-id="equivalence-of-bvps-with-minimization-problems"><span class="header-section-number">11.4.2</span> Equivalence of BVPs with minimization problems</h3>
<p>In this section, we will specialize to a boundary value problems of the following form (a so-called <em>Sturm-Liouville problem</em>): <span id="eq-e1"><span class="math display">\[
  - \frac{ \mathrm{d}^{}  }{\mathrm{d}x^{} } \left(p(x) \frac{ \mathrm{d}^{} y }{\mathrm{d}x^{} } (x)\right)+q(x)y(x)=f(x),
\quad 0 \leq x \leq 1, \quad
y(0)=y(1)=0.
\tag{11.30}\]</span></span> Here <span class="math inline">\(p\)</span>, <span class="math inline">\(q\)</span> and <span class="math inline">\(f\)</span> are sufficiently smooth functions from <span class="math inline">\([0,1]\)</span> to <span class="math inline">\(\mathbb{R}\)</span>; for details see below. We can reformulate this BVP as a minimization problem for an integral expression: The solution <span class="math inline">\(y(x)\)</span> minimizes the integral <span id="eq-int"><span class="math display">\[
  I[\phi]
  =\int_0^1\Big(p(x) (\phi'(x))^2+q(x)
  \phi(x)^2-2f(x)\phi(x)\Big)dx;
\tag{11.31}\]</span></span> over all functions <span class="math inline">\(\phi\)</span> that satisfy the boundary conditions that is, if <span class="math inline">\(\phi\)</span> is any function satisfying the boundary conditions, then one has <span class="math inline">\(I[y] \leq I[\phi]\)</span>.</p>
<p>More precisely, let <span class="math inline">\(\mathcal{C}^2_0[0,1]\)</span> denote the space of <span class="math inline">\(\mathcal{C}^2\)</span> functions on <span class="math inline">\([0,1]\)</span> that vanish at the endpoints of the interval. One has:</p>
<div id="it:miniunique" class="theorem">
<p><strong>Theorem 11</strong>. <em><span id="thm:rrequiv" label="thm:rrequiv"></span> Let <span class="math inline">\(p \in \mathcal{C}^1[0,1]\)</span>, and <span class="math inline">\(q,f \in \mathcal{C}[0,1]\)</span>. Further, suppose that there exists a constant <span class="math inline">\(\delta&gt;0\)</span> such that <span class="math display">\[
\forall  x \in [0,1]: \quad p(x) \geq \delta, \; q(x) \geq 0.
\]</span> Then, for any function <span class="math inline">\(y \in \mathcal{C}^2_{0}[0,1]\)</span>, the following conditions are equivalent.</em></p>
<ol type="i">
<li><p><em><span id="it:bvpunique" label="it:bvpunique"></span> <span class="math inline">\(y\)</span> is the unique solution of the boundary value problem in Eq.&nbsp;<a href="#e1" data-reference-type="eqref" data-reference="e1">[e1]</a>.</em></p></li>
<li><p><em><span class="math inline">\(y\)</span> is the unique function in <span class="math inline">\(\mathcal{C}^2_{0}[0,1]\)</span> which minimizes the integral <span class="math inline">\(I[y]\)</span> in Eq.&nbsp;<a href="#int" data-reference-type="eqref" data-reference="int">[int]</a>.</em></p></li>
</ol>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span><em>Proof.</em> Here we prove only (<a href="#it:miniunique" data-reference-type="ref" data-reference="it:miniunique">11</a>) <span class="math inline">\(\Rightarrow\)</span> (<a href="#it:bvpunique" data-reference-type="ref" data-reference="it:bvpunique">[it:bvpunique]</a>), neglecting the aspect of uniqueness. For a full proof, see <span class="citation" data-cites="Burden_Faires">(<a href="references.html#ref-Burden_Faires" role="doc-biblioref">Burden and Faires 2010</a> Theorem 11.4)</span> and references quoted there.</p>
<p>If <span class="math inline">\(y\)</span> minimizes the integral <span class="math inline">\(I[y]\)</span>, then for any fixed <span class="math inline">\(u \in \mathcal{C}^2_0[0,1]\)</span>, the function <span class="math display">\[
\epsilon \mapsto I[y+\epsilon u]
\]</span> has a minimum at <span class="math inline">\(\epsilon=0\)</span>. Therefore, its derivative at <span class="math inline">\(\epsilon=0\)</span> must vanish:</p>
<p><span class="math display">\[
\begin{aligned}
0 &amp;= \frac{\mathrm{d}}{\mathrm{d}\epsilon} I[y+\epsilon u] \Big\lvert_{\epsilon=0}
\\
&amp;= \frac{\mathrm{d}}{\mathrm{d}\epsilon}\Big\lvert_{\epsilon=0}
   \int_0^1 \Big(p(x) (y'(x) + \epsilon u'(x))^2
   + q(x) (y(x) + \epsilon u(x))^2 - 2(y(x)+\epsilon u(x)) f(x)\Big)  dx
\\
&amp;\overset{\text{\footnotemark})}{=}  \int_0^1 \Big(2 p(x) (y'(x) + \epsilon u'(x)) u'(x)
   + 2 q(x) (y(x) + \epsilon u(x)) u(x) - 2 u(x) f(x)\Big)  \Big\lvert_{\epsilon=0} dx
\\
&amp;=  2 \int_0^1 \Big(p(x) y'(x) u'(x)
   + q(x) y(x) u(x) - u(x) f(x)\Big)  dx.
\end{aligned}
\]</span> We integrate by parts in the first term of the integral, <span class="math inline">\((p(x)y'(x))u'(x)\)</span>, noting that the boundary terms vanish since <span class="math inline">\(u(0)=u(1)=0\)</span>. This gives <span class="math display">\[
0 = \int_0^1 \Big( -(p(x) y'(x))'  
   + q(x) y(x)  - f(x)\Big) u(x)  \,dx
\]</span> Since this holds for all <span class="math inline">\(u \in \mathcal{C}^2_0[0,1]\)</span>, and since all functions under the integral sign are continuous, we can conclude that <span class="math display">\[
0 =  -(p y')'  + q y  - f
\]</span> on the entire interval <span class="math inline">\([0,1]\)</span>, which is what we wanted to show.&nbsp;◻</p>
</div>
</section>
<section id="approximating-the-integral" class="level3" data-number="11.4.3">
<h3 data-number="11.4.3" class="anchored" data-anchor-id="approximating-the-integral"><span class="header-section-number">11.4.3</span> Approximating the integral</h3>
<p>The Rayleigh-Ritz method makes use of the equivalence stated in Theorem&nbsp;<a href="#thm:rrequiv" data-reference-type="ref" data-reference="thm:rrequiv">[thm:rrequiv]</a>. The idea is to approximate the function that minimizes the integral <span class="math inline">\(I[\phi]\)</span>, rather than approximating the boundary value problem directly. That is, we try to find functions <span class="math inline">\(\phi\)</span> that make <span class="math inline">\(I[\phi]\)</span> as small as possible.</p>
<p>Of course, we cannot try <em>all</em> functions in the infinite dimensional vector space <span class="math inline">\(\mathcal{C}^2_{0}[0,1]\)</span>. Rather we choose a set of <span class="math inline">\(N\)</span> linearly independent functions (“basis functions”<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>) <span class="math inline">\(\phi_i\)</span> with <span class="math inline">\(\phi_i(0)=\phi_i(1)=0\)</span>, and use an arbitrary linear combination <span id="eq-trialf"><span class="math display">\[
  \phi(x)=\sum_{i=1}^N c_i\phi_i(x)
\tag{11.32}\]</span></span> of these functions as our trial function. The coefficients <span class="math inline">\(c_i\)</span> are to minimize the integral. There is a large freedom of choice for the functions <span class="math inline">\(\phi_j\)</span>, and this can be exploited to adapt the approximation method to our needs. We leave the choice of <span class="math inline">\(\phi_j\)</span> open for the moment, and will fix them later on.</p>
<p>Substituting the trial function <a href="#trialf" data-reference-type="eqref" data-reference="trialf">[trialf]</a> into <span class="math inline">\(I[\phi]\)</span> in <a href="#int" data-reference-type="eqref" data-reference="int">[int]</a> gives <span class="math display">\[
I[\phi]=\int_0^1\left(p(x)\bigg(\sum_{i=1}^N c_i\phi'_i(x)\bigg)^2
  +q(x)\bigg(\sum_{i=1}^N c_i\phi_i(x)\bigg)^2
  -2f(x)\sum_{i=1}^N c_i\phi_i(x)\right)dx.
\]</span> We now minimize over the real parameters <span class="math inline">\(c_i\)</span>. They will be fixed by the necessary requirement for having an extremum, namely, that all partial derivatives vanish, <span class="math display">\[
\begin{gathered}
0=\frac{\partial I[\phi]}{\partial c_j}
=\int_0^1\left(2p(x)\sum_{i=1}^Nc_i\phi'_i(x)\phi'_j(x)
+2q(x)\sum_{i=1}^Nc_i\phi_i(x)\phi_j(x)-2f(x)\phi_j(x)\right)dx
\\\text{ for all }j=1,\dots,N.
\end{gathered}
\]</span> This is a linear system of the form <span id="eq-e3"><span class="math display">\[
\sum_{i=1}^N A ^{(j,i)}c ^{(i)}=b ^{(j)},~~~~j=1,\dots,N,
\tag{11.33}\]</span></span> where <span class="math display">\[
\begin{aligned}
\label{eq:ea}
A ^{(j,i)}&amp;=\int_0^1\Big(p(x)\phi'_i(x)\phi'_j(x)+q(x)\phi_i(x)\phi_j(x)\Big)dx,\\
\label{eq:eb}
b ^{(j)}&amp;=\int_0^1 f(x)\phi_j(x) dx.
\end{aligned}
\]</span> Once the basis functions <span class="math inline">\(\phi_j\)</span> are chosen, we can compute the components of <span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(\mathbf{b}\)</span>, solve the linear system <a href="#eq-e3" class="quarto-xref">Eq.&nbsp;<span>11.33</span></a> for <span class="math inline">\(\mathbf{c}\)</span>, and then obtain the approximation function <span class="math inline">\(\phi\)</span> from <a href="#trialf" data-reference-type="eqref" data-reference="trialf">[trialf]</a>.</p>
</section>
<section id="choosing-the-basis-functions" class="level3" data-number="11.4.4">
<h3 data-number="11.4.4" class="anchored" data-anchor-id="choosing-the-basis-functions"><span class="header-section-number">11.4.4</span> Choosing the basis functions</h3>
<p>The question is now how to choose the functions <span class="math inline">\(\phi_j\)</span> so that we get a reasonable numerical approximation of the solution <span class="math inline">\(y(x)\)</span>, which is furthermore fast to compute. Our requirements are:</p>
<ul>
<li><p>The <span class="math inline">\(\phi_j\)</span> need to satisfy the boundary conditions: <span class="math inline">\(\phi_j(0)=\phi_j(1)=0\)</span>.</p></li>
<li><p>They should be sufficiently smooth. Note that, for purposes of numerical approximation, it is not be necessary to require two continuous derivatives (as for the ODE solution). Since we deal only with integral expressions in <span class="math inline">\(\phi_j\)</span> and <span class="math inline">\(\phi_j'\)</span>, it should suffice if <span class="math inline">\(\phi_j\)</span> has one derivative that exists almost everywhere and is piecewise continuous, or at least integrable.</p></li>
<li><p>They should be designed so that their linear combinations can approximate a wide range of functions. (This may seem a bit vague; but e.g.&nbsp;choosing all the <span class="math inline">\(\phi_j\)</span> with support in the interval <span class="math inline">\([0,\frac{1}{2}]\)</span> would clearly be a bad idea.)</p></li>
<li><p>They should be simple enough so that the integrals for <span class="math inline">\(A ^{(i,j)}\)</span> and <span class="math inline">\(b ^{(j)}\)</span> in Eqs.&nbsp;<a href="#eq:ea" data-reference-type="eqref" data-reference="eq:ea">[eq:ea]</a> and <a href="#eq:eb" data-reference-type="eqref" data-reference="eq:eb">[eq:eb]</a> can reasonably be evaluated - if possible, explicitly.</p></li>
<li><p>If possible, not many of them should have overlapping support, so that the matrix <span class="math inline">\(\mathbf{A}\)</span> is sparse, i.e., many of its entries are zero. This will make the linear equation system in Eq.&nbsp;<a href="#eq-e3" class="quarto-xref">Eq.&nbsp;<span>11.33</span></a> fast to solve.</p></li>
</ul>
<p>A simple choice of basis functions, satisfying the above requirements, are the piecewise linear functions <span class="math display">\[
\phi_i(x)=\left\{\begin{array}{ll}
0&amp;\mbox{if }0\leq x\leq x_{i-1};\\
\frac{1}{h_{i-1}}(x-x_{i-1})&amp;\mbox{if }x_{i-1}&lt; x\leq x_{i};\\
\frac{1}{h_{i}}(x_{i+1}-x)&amp;\mbox{if }x_{i}&lt; x\leq x_{i+1};\\
0&amp;\mbox{if }x_{i+1}&lt; x\leq 1
\end{array}\right.
\]</span> for some conveniently chosen mesh points <span class="math display">\[
0=x_0&lt;x_1&lt;x_2&lt;\dots&lt;x_N&lt;x_{N+1}=1.
\]</span> The <span class="math inline">\(h_i\)</span> are the distances between neighbouring mesh points, <span class="math inline">\(h_i=x_{i+1}-x_i\)</span>; note that the mesh points need not be equally spaced. These basis functions <span class="math inline">\(\phi_i\)</span> have simple piecewise constant derivatives, <span class="math display">\[
\phi'_i(x)=\left\{\begin{array}{ll}
0&amp;\mbox{if }0 &lt; x &lt; x_{i-1},\\
\frac{1}{h_{i-1}}&amp;\mbox{if }x_{i-1}&lt; x &lt;  x_{i},\\
-\frac{1}{h_{i}}&amp;\mbox{if }x_{i}&lt; x &lt; x_{i+1},\\
0&amp;\mbox{if }x_{i+1} &lt; x &lt; 1.
\end{array}\right.
\]</span> A particular simplifying feature of this set of basis functions is that only neighbouring functions have any overlap, i.e., <span class="math display">\[
\phi_i(x)\phi_j(x)=0 ~~\text{ and }~~
\phi'_i(x)\phi'_j(x)=0~~\text{ unless }j\in\{i-1,i,i+1\}.
\]</span> This implies that the matrix <span class="math inline">\(\mathbf{A}\)</span> is tridiagonal. To calculate the entries of <span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(\mathbf{b}\)</span> in <span class="quarto-unresolved-ref">?eq-ea</span> and <span class="quarto-unresolved-ref">?eq-eb</span>, the following integrals need to be evaluated: <span class="math display">\[
\begin{aligned}
Q_{1,i} &amp;= \left(\frac{1}{h_i}\right)^2\int_{x_i}^{x_{i+1}}
  (x_{i+1}-x)(x-x_i)q(x)dx,\\
Q_{2,i} &amp;= \left(\frac{1}{h_{i-1}}\right)^2\int_{x_{i-1}}^{x_{i}}
  (x-x_{i-1})^2q(x)dx,\\
Q_{3,i} &amp;= \left(\frac{1}{h_{i}}\right)^2\int_{x_{i}}^{x_{i+1}}
  (x_{i+1}-x)^2q(x)dx,\\
Q_{4,i} &amp;= \left(\frac{1}{h_{i-1}}\right)^2\int_{x_{i-1}}^{x_{i}}
  p(x)dx,\\
Q_{5,i} &amp;= \frac{1}{h_{i-1}}\int_{x_{i-1}}^{x_{i}}
  (x-x_{i-1})f(x)dx,\\
Q_{6,i} &amp;= \frac{1}{h_{i}}\int_{x_{i}}^{x_{i+1}}
  (x_{i+1}-x)f(x)dx.
\end{aligned}
\]</span> Then <span class="math display">\[
\begin{aligned}
A ^{(i,i)}&amp;=Q_{4,i}+Q_{4,i+1}+Q_{2,i}+Q_{3,i},~~~&amp;i&amp;=1,\dots,N,\\
A ^{(i,i+1)}&amp;=-Q_{4,i+1}+Q_{1,i},~~~&amp;i&amp;=1,\dots,N-1,\\
A ^{(i,i-1)}&amp;=-Q_{4,i}+Q_{1,i-1},~~~&amp;i&amp;=2,\dots,N,\\
b ^{(i)}&amp;=Q_{5,i}+Q_{6,i},~~~&amp;i&amp;=1,\dots,N.
\end{aligned}
\]</span> One way to evaluate the <span class="math inline">\(6N\)</span> integrals is to approximate the functions <span class="math inline">\(q(x)\)</span>, <span class="math inline">\(p(x)\)</span>, and <span class="math inline">\(f(x)\)</span> by their linear interpolating polynomials. That is, we write <span class="math display">\[
q(x)=\sum_{i=0}^{N+1}q(x_i)\phi_i(x)+O(h^2),
\]</span> and similarly for <span class="math inline">\(p\)</span> and <span class="math inline">\(f\)</span>, where the <span class="math inline">\(\phi_i\)</span> are as given above for <span class="math inline">\(i=1,\dots,N\)</span>, and <span class="math display">\[
\begin{aligned}
\phi_0(x)&amp;=\left\{\begin{array}{ll}
  \frac{x_1-x}{x_1}&amp;\text{if }0\leq x\leq x_1,\\
  0&amp;\text{elsewhere};\end{array}\right.
  \\
  \phi_{N+1}(x)&amp;=\left\{\begin{array}{ll}
  \frac{x-x_N}{1-x_N}&amp;\text{if }x_N\leq x\leq 1,\\
  0&amp;\text{elsewhere}.\end{array}\right.
\end{aligned}
\]</span> The integrals are now trivial to evaluate, for example <span class="math display">\[
\begin{aligned}
Q_{1,i} &amp;= \left(\frac{1}{h_i}\right)^2\int_{x_i}^{x_{i+1}}
  (x_{i+1}-x)(x-x_i)q(x)dx\\
  &amp;\approx\left(\frac{1}{h_i}\right)^2\int_{x_i}^{x_{i+1}}
  (x_{i+1}-x)(x-x_i)\left(
  q(x_i)\frac{x_{i+1}-x}{h_i}+q(x_{i+1})\frac{x-x_i}{h_i}
  \right)dx\\
  &amp;=\frac{h_i}{12}\left(q(x_i)+q(x_{i+1})\right).
\end{aligned}
\]</span> Similarly we find<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> <span class="math display">\[
\begin{aligned}
Q_{2,i}&amp;\approx\frac{h_{i-1}}{12}\left(3q(x_i)+q(x_{i-1})\right),\\
Q_{3,i}&amp;\approx\frac{h_{i}}{12}\left(3q(x_i)+q(x_{i+1})\right),\\
Q_{4,i}&amp;\approx\frac{1}{2 h_{i-1}}\left(p(x_i)+p(x_{i-1})\right),\\
Q_{5,i}&amp;\approx\frac{h_{i-1}}{6}\left(2f(x_i)+f(x_{i-1})\right),\\
Q_{6,i}&amp;\approx\frac{h_{i}}{6}\left(2f(x_i)+f(x_{i+1})\right).
\end{aligned}
\]</span> After this calculation, we can now simply solve the linear system <a href="#eq-e3" class="quarto-xref">Eq.&nbsp;<span>11.33</span></a> for the coefficients <span class="math inline">\(\mathbf{c}=(c_i)\)</span> in the trial function in order to find the approximation <span class="math display">\[
y(x)\approx\sum_{i=1}^N c_i\phi_i(x).
\]</span> An example for a computer implementation of the algorithm will be discussed in the Practicals.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-Burden_Faires" class="csl-entry" role="listitem">
Burden, Richard L., and J. Douglas Faires. 2010. <em>Numerical <span>Analysis</span></em>. 9th ed. Brooks Cole.
</div>
</div>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p><em>To explain the notation: These are the partial derivatives of <span class="math inline">\(f\)</span> by its second and third argument, respectively.</em><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Note the change of convention: Our step size is now <span class="math inline">\(h = (b-a)/(N+1)\)</span>, and we have <span class="math inline">\(N+2\)</span> (not <span class="math inline">\(N+1\)</span>) mesh points, of which <span class="math inline">\(N\)</span> are inside the interval <span class="math inline">\((a,b)\)</span>. This convention, which we shall use from now on, is very useful for boundary value problems: the function <span class="math inline">\(y\)</span> needs to be determined at <span class="math inline">\(x_1,\ldots,x_N\)</span> but is already known at <span class="math inline">\(x_0\)</span> and <span class="math inline">\(x_{N+1}\)</span>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>While these are usually called “basis functions”, e.g.&nbsp;in <span class="citation" data-cites="Burden_Faires">(<a href="references.html#ref-Burden_Faires" role="doc-biblioref">Burden and Faires 2010</a>)</span>, they are of course not a basis of the space <span class="math inline">\(\mathcal{C}^2_{0}[0,1]\)</span>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Note that Burden/Faires <span class="citation" data-cites="Burden_Faires">(<a href="references.html#ref-Burden_Faires" role="doc-biblioref">Burden and Faires 2010</a>)</span> reports the formula for <span class="math inline">\(Q_{4,i}\)</span> incorrectly.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./ivp.html" class="pagination-link  aria-label=" &lt;span="" value="" problems&lt;="" span&gt;"="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Initial Value Problems</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./pde.html" class="pagination-link" aria-label="<span class='chapter-number'>12</span>&nbsp; <span class='chapter-title'>Partial Differential Equations</span>">
        <span class="nav-page-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Partial Differential Equations</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/gustavdelius/NumericalAnalysis/edit/master/bvp.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></div></div></footer></body></html>